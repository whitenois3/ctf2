/// @title EIP-1153 CTF
/// @author clabby <https://github.com/clabby>

////////////////////////////////////////////////////////////////
//                         INTERFACE                          //
////////////////////////////////////////////////////////////////

#define function startLoan() nonpayable returns ()
#define function borrow(address token, uint256 amount, address to) nonpayable returns ()

#define function transfer(address to, uint256 amount) nonpayable returns (bool)
#define function balanceOf(address addr) view returns (uint256)

#define function bankroll() nonpayable returns ()

////////////////////////////////////////////////////////////////
//                         CONSTANTS                          //
////////////////////////////////////////////////////////////////

/// @notice Transient storage slot for the reentrancy mutex
#define constant MUTEX = FREE_STORAGE_POINTER()

/// @notice The slot for the length of the `borrows` array in transient storage
/// @dev The `borrows` array contains elements that are 64 bytes in size. The first
/// slot begins at this value + 1.
#define constant BORROWS = FREE_STORAGE_POINTER()

/// @notice "Not the borrower!" string.
/// @dev The length of the string (17 bytes) is prepended to the contents of the string.
/// Store at 1 byte before the desired destination of the string contents in memory.
#define constant REJECT_BORROWER = 0x114e6f742074686520626f72726f77657221

////////////////////////////////////////////////////////////////
//                           ERRORS                           //
////////////////////////////////////////////////////////////////

/// @notice RejectBorrower error selector
#define error RejectBorrower(string)

////////////////////////////////////////////////////////////////
//                            MAIN                            //
////////////////////////////////////////////////////////////////

/// @notice Execution entry point
#define macro MAIN() = {
    // Dispatch functions based on selector
    // TODO: Maybe use a jumptable >:D
    pc calldataload 0xE0 shr // [selector]
    dup1 __FUNC_SIG(borrow)    eq borrow     jumpi
    dup1 __FUNC_SIG(startLoan) eq start_loan jumpi

    // Revert if no selectors matched
    0x00 dup1 revert

    borrow:
        BORROW(fail)
    start_loan:
        START_LOAN(fail)
    fail:
        // Bubble up revert message from call (if there is any)
        returndatasize       // [returndatasize]
        dup1                 // [returndatasize, returndatasize]
        0x00 dup1            // [0x00, 0x00, returndatasize, returndatasize]
        returndatacopy       // [returndatasize]
        0x00 revert          // []
}

////////////////////////////////////////////////////////////////
//                      INTERNAL MACROS                       //
////////////////////////////////////////////////////////////////

/// @notice Locks the transient reentrancy mutex by placing the borrower's
/// address in the slot.
/// @dev There is no need to zero-out the `MUTEX` slot because of EIP-1153!
#define macro TSTORE_BORROWER() = takes (1) {
    // Input stack:             [borrower]

    // TODO: huff-rs #218
    // [MUTEX] tstore
    [MUTEX] sstore

    // Return stack:            []
}

/// @notice Reverts if `msg.sender` is not the transient borrower.
///
/// SAFETY:
///  - The `msize` opcode is used to set the value for a single byte at mem[0x23].
///    This value is intended to be 0x20, so if this macro is invoked in a position
///    where `msize != 0x20`, the revert data will be malformed.
#define macro ASSERT_BORROWER() = takes (3) {
    // Input stack:          // [condition]

    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x71]
    // RejectBorrower(string)
    0x5205e60e               // [error_selector]
    0x00 mstore              // []
    msize 0x3F mstore8       // []
    [REJECT_BORROWER]        // [message]
    0x51 mstore              // []

    // Revert with custom error
    0x55 0x1C revert

    do_not_throw:

    // Return stack:            []
}

/// @notice Retrieves this address' balance of an ERC-20 compliant token
#define macro SELF_BALANCE_OF() = takes (1) returns (1) {
    // Input stack:             [token]

    __FUNC_SIG(balanceOf)    // [balanceOf_selector, token]
    0x00 mstore              // [token]
    address 0x20 mstore      // [token]
    0x20 0x24 0x1C dup3      // [ret_size, args_offset, args_size, ret_offset, token]
    swap4 gas staticcall     // [success]

    // Return stack:            [success]
}

////////////////////////////////////////////////////////////////
//                      EXTERNAL MACROS                       //
////////////////////////////////////////////////////////////////

/// @notice Start a loan callframe.
/// @param `fail` Jump label pointing to failure logic in the `MAIN` macro
#define macro START_LOAN(fail) = {
    // TODO: huff-rs #208
    // caller [MUTEX] tstore
    caller [MUTEX] sstore    // []

    // Hand control to the caller so they can start borrowing tokens
    __FUNC_SIG(bankroll)     // [bankroll_selector]
    0x00 mstore              // []
    0x00 dup1 0x04 0x1C dup3 // [value, args_offset, args_size, ret_offset, ret_size]
    caller gas call          // [success]

    // Revert if call to flash loan receiver failed
    iszero <fail> jumpi      // []

    // TODO: tload
    [BORROWS] sload          // [num_borrows]
    0x02                     // [slot_idx, num_borrows]
    debt_collector:
        // TODO - Ensure all debt has been returned

    stop
}

/// @notice Can be called by the current `borrower` only.
/// @param Accepts abi.encodePacked(address token, uint256 amount, address to)
/// as the calldata.
#define macro BORROW(fail) = {
    // Unpack calldata params
    0x60                     // [0x60]
    0x04 calldataload        // [cd[0x00:0x20], 0x60]
    dup2 shr                 // [token, 0x60]
    0x18 calldataload        // [amount, token, 0x60]
    0x38 calldataload        // [cd[0x4C:0x6C], amount, token, 0x60]
    dup4 shr                 // [to, amount, token, 0x60]
    swap3 pop                // [amount, token, to]

    // TODO: huff-rs #218
    // [MUTEX] tload         // [borrower, amount, token, to]
    [MUTEX] sload            // [borrower, amount, token, to]
    caller eq                // [borrower == msg.sender, amount, token, to]

    // SAFETY: `msize = 0` at this invocation every time.
    ASSERT_BORROWER()        // [amount, token, to]

    // Update number of borrows
    // TODO: tload / tstore
    [BORROWS] sload          // [len(borrows), amount, token, to]
    dup1                     // [len(borrows), len(borrows), amount, token, to]
    0x01 add                 // [len(borrows) + 0x01, len(borrows), amount, token, to]
    [BORROWS] sstore         // [len(borrows), amount, token, to]

    // Get the start of the next available `Borrow` slot (64 bytes each)
    0x01 shl                 // [0x02 * len(borrows), amount, token, to]
    0x02 add                 // [0x02 * len(borrows) + 0x02, amount, token, to]

    // Get this contract's balance of the requested token
    dup3 SELF_BALANCE_OF()   // [success, borrow_slot_start, amount, token, to]

    // Revert if `balanceOf` call failed
    // TODO: Maybe ensure the balance is > 0 too? Not really necessary, tho.
    iszero <fail> jumpi      // [borrow_slot_start, amount, token, to]

    // Store `Balance` struct in transient storage array
    // TODO: tstore
    0x20 mload               // [initial_balance, borrow_slot_start, amount, token, to]
    dup2 sstore              // [borrow_slot_start, amount, token, to]
    dup3 swap1 0x01 add      // [borrow_slot_start + 0x01, token, amount, token, to]
    sstore                   // [amount, token, to]

    // Call `transfer` on target token
    __FUNC_SIG(transfer)     // [transfer_selector, amount, token, to]
    0x00 mstore              // [amount, token, to]
    0x40 mstore              // [token, to]
    swap1 0x20 mstore        // [token]
    0x00 dup1 0x44 0x1C dup3 // [value, args_offset, args_size, ret_offset, ret_size, token]
    dup6 gas call            // [success, token]

    // Revert if `transfer` call failed
    iszero <fail> jumpi      // [token]
    
    stop
}
