/// @title EIP-1153 CTF
/// @author clabby <https://github.com/clabby>
/// @author abigger87 <https://github.com/abigger87>
///
/// TODO:
/// - [ ] Flashloans are custodial at the moment, as this contract must hold the tokens that are
///       to be loaned. The challenge would definitely be a bit more interesting if we went with
///       the original implementation's non-custodial design, but we would need to make a modified
///       token that has irrevocable approval to this contract *or* implement the flashloan logic
///       into the ERC20 itself.
/// - [ ] Design and implement attack vector.

////////////////////////////////////////////////////////////////
///                         INTERFACE                        ///
////////////////////////////////////////////////////////////////

/// TransientLoan.huff
#define function startLoan() nonpayable returns ()
#define function borrow(address token, uint256 amount, address to) nonpayable returns ()
#define function submit(uint256) nonpayable returns ()

/// IFlashLoanReceiver.sol
#define function bankroll() nonpayable returns ()

/// ERC-20 functions
#define function transfer(address to, uint256 amount) nonpayable returns (bool)
#define function balanceOf(address addr) view returns (uint256)

////////////////////////////////////////////////////////////////
//                         CONSTANTS                          //
////////////////////////////////////////////////////////////////

/// @notice Transient storage slot for the reentrancy mutex
#define constant MUTEX = FREE_STORAGE_POINTER()

/// @notice The slot for the length of the `borrows` array in transient storage
/// @dev The `borrows` array contains elements that are 64 bytes in size. The first
/// slot begins at this value + 1.
#define constant BORROWS = FREE_STORAGE_POINTER()

/// @notice "Not the borrower!" string.
/// @dev The length of the string (17 bytes) is prepended to the contents of the string.
/// Store at 1 byte before the desired destination of the string contents in memory.
#define constant REJECT_BORROWER = 0x114e6f742074686520626f72726f77657221

/// @notice "Repay your debt!" string.
/// @dev The length of the string (16 bytes) is prepended to the contents of the string.
/// Store at 1 byte before the desired destination of the string contents in memory.
#define constant REPAY_DEBT = 0x10526570617920796f7572206465627421

/// @notice The maximum borrow (1000 wei)
#define constant MAX_BORROW = 0x3E8

////////////////////////////////////////////////////////////////
///                           MAIN                           ///
////////////////////////////////////////////////////////////////

/// @notice Execution entry point
#define macro MAIN() = {
    // Dispatch functions based on selector
    // TODO: Maybe use a jumptable >:D
    pc calldataload 0xE0 shr // [selector]
    dup1 __FUNC_SIG(borrow)    eq borrow     jumpi
    dup1 __FUNC_SIG(startLoan) eq start_loan jumpi
    dup1 __FUNC_SIG(submit)    eq submit     jumpi
    dup1 0x00000001            eq delegate   jumpi

    // Revert if no selectors matched
    returndatasize returndatasize revert

    borrow:
        BORROW(bubble_fail)
    start_loan:
        START_LOAN(bubble_fail)
    submit:
        SUBMIT_TOKENS(bubble_fail)
    delegate:
        PERFORM_DELEGATE_CALL(bubble_fail)
    bubble_fail:
        // Bubble up revert message from returndata (if there is any)
        returndatasize       // [returndatasize]
        dup1                 // [returndatasize, returndatasize]
        0x00 dup1            // [0x00, 0x00, returndatasize, returndatasize]
        returndatacopy       // [returndatasize]
        0x00 revert          // []
}

////////////////////////////////////////////////////////////////
///                     INTERNAL MACROS                      ///
////////////////////////////////////////////////////////////////

/// @notice Locks the transient reentrancy mutex by placing the borrower's
/// address in the slot.
/// @dev There is no need to zero-out the `MUTEX` slot because of EIP-1153!
#define macro TSTORE_BORROWER() = takes (1) {
    // Input stack:             [borrower]

    // [MUTEX] tstore
    [MUTEX] sstore

    // Return stack:            []
}

/// @notice Reverts with the `RejectBorrower(string)` error if the condition
/// is false.
///
/// SAFETY:
///  - The `msize` opcode is used to set the value for a single byte at mem[0x23].
///    This value is intended to be 0x20, so if this macro is invoked in a position
///    where `msize != 0x20`, the revert data will be malformed.
#define macro ASSERT_BORROWER() = takes (1) {
    // Input stack:          // [condition]

    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x71]
    // RejectBorrower(string)
    0x5205e60e               // [error_selector]
    0x00 mstore              // []
    msize 0x3F mstore8       // []
    [REJECT_BORROWER]        // [message]
    0x51 mstore              // []

    // Revert with custom error
    0x64 0x1C revert

    do_not_throw:

    // Return stack:            []
}

/// @notice Reverts with the `OubstandingDebt(string)` error if the condition
/// is false.
#define macro ASSERT_BALANCE() = takes (1) {
    // Input stack:          // [condition]

    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x71]
    // OutstandingDebt(string)
    0x17167f90               // [error_selector]
    0x00 mstore              // []
    0x20 dup1 mstore         // []
    [REPAY_DEBT]             // [message]
    0x50 mstore              // []

    // Revert with custom error
    0x64 0x1C revert

    do_not_throw:

    // Return stack:            []
}

/// @notice Reverts with the `OubstandingDebt(string)` error if the condition
/// is false.
#define macro ASSERT_LOAN_THRESHOLD() = takes (1) {
    // Input stack:          // [condition]

    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x20]
    // ExceedsLoanThreshold()
    0x12492d44               // [error_selector]
    0x00 mstore              // []

    // Revert with custom error
    0x04 0x1C revert

    do_not_throw:

    // Return stack:            []
}

/// @notice Reverts with the `OubstandingDebt(string)` error if the condition
/// is false.
#define macro ASSERT_NO_REENTRANCY() = takes (1) {
    // Input stack:          // [condition]

    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x20]
    // NoReentrancy()
    0x583fe886               // [error_selector]
    0x00 mstore              // []

    // Revert with custom error
    0x04 0x1C revert

    do_not_throw:

    // Return stack:            []
}

/// @notice Retrieves this address' balance of an ERC-20 compliant token
#define macro SELF_BALANCE_OF() = takes (1) returns (1) {
    // Input stack:             [token]

    __FUNC_SIG(balanceOf)    // [balanceOf_selector, token]
    returndatasize mstore    // [token]
    address 0x20 mstore      // [token]
    0x20 0x24 0x1C dup3      // [ret_size, args_offset, args_size, ret_offset, token]
    swap4 gas staticcall     // [success]

    // Return stack:            [success]
}

////////////////////////////////////////////////////////////////
///                     EXTERNAL MACROS                      ///
////////////////////////////////////////////////////////////////

/// @notice Start a loan callframe.
/// @param `fail` Jump label pointing to failure logic in the `MAIN` macro
#define macro START_LOAN(fail) = {
    // Do not allow reentrancy
    // TODO: Custom error
    [MUTEX] sload iszero     // [mutex == 0]
    ASSERT_NO_REENTRANCY()   // []

    // caller [MUTEX] tstore
    caller [MUTEX] sstore    // []

    // Hand control to the caller so they can start borrowing tokens
    __FUNC_SIG(bankroll)     // [bankroll_selector]
    returndatasize mstore    // []
    returndatasize           // [ret_size]
    returndatasize           // [ret_offset, ret_size]
    0x04 0x1C dup3           // [value, args_offset, args_size, ret_offset, ret_size]
    caller gas call          // [success]

    // Revert if call to flash loan receiver failed
    iszero <fail> jumpi      // []

    // TODO: tload
    [BORROWS] sload          // [num_borrows]
    0x02                     // [slot_idx, num_borrows]
    debt_collector:
        // Complete loop if all `Borrow`s have been accounted for.
        // We check at the beginning of the loop rather than the end in case 0 borrows have been
        // taken out.
        dup1                 // [slot_idx, slot_idx, num_borrows]
        dup3 0x01 shl        // [num_borrows * 0x02, slot_idx, slot_idx, num_borrows]
        0x02 add             // [num_borrows * 0x02 + 0x02, slot_idx, slot_idx, num_borrows]
        eq debt_collected jumpi

        // Get the `Borrow` struct from transient storage at slot_idx
        // TODO: tload
        dup1 sload           // [init_balance, slot_idx, num_borrows]
        dup2 0x01 add sload  // [token, init_balance, slot_idx, num_borrows]

        // Get this contract's current balance of `token` and revert if the
        // `balanceOf` call fails
        SELF_BALANCE_OF()    // [success, init_balance, slot_idx, num_borrows]
        iszero <fail> jumpi  // [init_balance, slot_idx, num_borrows]

        // Assert that this contract's balance of `token` is >= to its initial balance
        0x20 mload           // [token.balanceOf(address(this)), init_balance, slot_idx, num_borrows]
        lt iszero            // [token.balanceOf(address(this)) >= init_balance, slot_idx, num_borrows]
        ASSERT_BALANCE()     // [slot_idx, num_borrows]

        // Move on to next `Borrow` slot
        0x02 add             // [slot_idx + 0x02, num_borrows]
        // Continue loop
        debt_collector jump
    debt_collected:
        stop
}

/// @notice Can be called by the current `borrower` only.
/// @param `fail` Jump label pointing to failure logic in the `MAIN` macro
/// @dev Accepts abi.encodePacked(address token, uint256 amount, address to)
/// as the calldata.
#define macro BORROW(fail) = {
    // Unpack calldata params
    0x60                     // [0x60]
    0x04 calldataload        // [cd[0x00:0x20], 0x60]
    dup2 shr                 // [token, 0x60]
    0x18 calldataload        // [amount, token, 0x60]
    0x38 calldataload        // [cd[0x4C:0x6C], amount, token, 0x60]
    dup4 shr                 // [to, amount, token, 0x60]
    swap3 pop                // [amount, token, to]

    // Ensure the loaned amount is <= MAX_BORROW
    [MAX_BORROW] dup2        // [amount, MAX_BORROW, amount, token, to]
    gt iszero                // [amount <= MAX_BORROW, amount, token, to]
    ASSERT_LOAN_THRESHOLD()  // [amount, token, to]

    // [MUTEX] tload         // [borrower, amount, token, to]
    [MUTEX] sload            // [borrower, amount, token, to]
    caller eq                // [borrower == msg.sender, amount, token, to]

    // SAFETY: `msize = 0` at this invocation every time.
    ASSERT_BORROWER()        // [amount, token, to]

    // Update number of borrows
    // TODO: tload / tstore
    [BORROWS] sload          // [len(borrows), amount, token, to]
    dup1                     // [len(borrows), len(borrows), amount, token, to]
    0x01 add                 // [len(borrows) + 0x01, len(borrows), amount, token, to]
    [BORROWS] sstore         // [len(borrows), amount, token, to]

    // Get the start of the next available `Borrow` slot (64 bytes each)
    0x01 shl                 // [0x02 * len(borrows), amount, token, to]
    0x02 add                 // [0x02 * len(borrows) + 0x02, amount, token, to]

    // Get this contract's balance of the requested token
    dup3 SELF_BALANCE_OF()   // [success, borrow_slot_start, amount, token, to]

    // Revert if `balanceOf` call failed
    // TODO: Maybe ensure the balance is > 0 too? Not really necessary, tho.
    iszero <fail> jumpi      // [borrow_slot_start, amount, token, to]

    // Store `Balance` struct in transient storage array
    // TODO: tstore
    0x20 mload               // [initial_balance, borrow_slot_start, amount, token, to]
    dup2 sstore              // [borrow_slot_start, amount, token, to]
    dup3 swap1 0x01 add      // [borrow_slot_start + 0x01, token, amount, token, to]
    sstore                   // [amount, token, to]

    // Call `transfer` on target token
    __FUNC_SIG(transfer)     // [transfer_selector, amount, token, to]
    0x00 mstore              // [amount, token, to]
    0x40 mstore              // [token, to]
    swap1 0x20 mstore        // [token]
    0x00 dup1 0x44 0x1C dup3 // [value, args_offset, args_size, ret_offset, ret_size, token]
    dup6 gas call            // [success, token]

    // Revert if `transfer` call failed
    iszero <fail> jumpi      // [token]
    
    stop
}

/// @notice Performs a delegate call to a specific contract
/// TODO: Make it a challenge to reach this logic! ATM, it can be
/// reached directly from function dispatch.
#define macro PERFORM_DELEGATE_CALL(fail) = {
    0x04 calldataload        // [address << 0x60]
    0x60 shr                 // [address]

    returndatasize           // [0x00, address]
    returndatasize           // [0x00, 0x00, address]
    returndatasize           // [0x00, 0x00, 0x00, address]
    returndatasize           // [0x00, 0x00, 0x00, 0x00, address]
    swap4                    // [address, 0x00, 0x00, 0x00, 0x00]
    // TODO: Determine exact gas limit for the delegate call + 2 push ops and a tstore
    0x1000                   // [gas, address, 0x00, 0x00, 0x00, 0x00]
    delegatecall             // [success]
    iszero <fail> jumpi      // []

    stop
}

/// @notice Submit any amount of the mock ERC-20 token to receive an award 
#define macro SUBMIT_TOKENS(fail) = {
    // TODO
    stop
}
