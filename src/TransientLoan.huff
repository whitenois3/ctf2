/// @title EIP-1153 CTF
/// @author clabby <https://github.com/clabby>
/// @author abigger87 <https://github.com/abigger87>

////////////////////////////////////////////////////////////////
///                         INTERFACE                        ///
////////////////////////////////////////////////////////////////

/// TransientLoan.huff
#define event ChallengeSolved(address indexed eoa)
#define function startLoan() nonpayable returns ()
#define function borrow(address token, uint256 amount, address to) nonpayable returns ()
#define function submit() nonpayable returns ()
#define function isSolved() nonpayable returns (bool)
#define function enter() nonpayable returns ()
#define function write(bytes32, bytes32) nonpayable returns ()
/// @dev The signature is meant to throw attackers off- this function only takes
/// 32 bytes of calldata.
#define function atlas(uint256, uint256, uint256) nonpayable returns () 

/// IFlashLoanReceiver.sol
#define function bankroll() nonpayable returns ()

/// ERC-20 functions
#define function transfer(address to, uint256 amount) nonpayable returns (bool)
#define function transferFrom(address from, address to, uint256 amount) nonpayable returns (bool)
#define function balanceOf(address addr) view returns (uint256)

////////////////////////////////////////////////////////////////
//                         CONSTANTS                          //
////////////////////////////////////////////////////////////////

/// @notice Transient storage slot for the reentrancy mutex
#define constant MUTEX = FREE_STORAGE_POINTER()

/// @notice "Not the borrower!" string.
/// @dev The length of the string (17 bytes) is prepended to the contents of the string.
/// Store at 1 byte before the desired destination of the string contents in memory.
#define constant REJECT_BORROWER = 0x114e6f742074686520626f72726f77657221

/// @notice "Repay your debt!" string.
/// @dev The length of the string (16 bytes) is prepended to the contents of the string.
/// Store at 1 byte before the desired destination of the string contents in memory.
#define constant REPAY_DEBT = 0x10526570617920796f7572206465627421

/// @notice The maximum borrow (10 wei)
#define constant MAX_BORROW = 0x0A

/// @notice A 4 byte mask
#define constant FOUR_BYTE_MASK = 0xFFFFFFFF

////////////////////////////////////////////////////////////////
///                           MAIN                           ///
////////////////////////////////////////////////////////////////

/// @notice Execution entry point
#define macro MAIN() = {
    // Dispatch functions based on selector
    // TODO: Maybe use a jumptable >:D
    pc calldataload 0xE0 shr // [selector]
    dup1 __FUNC_SIG(borrow)    eq borrow     jumpi
    dup1 __FUNC_SIG(enter)     eq enter      jumpi
    dup1 __FUNC_SIG(write)     eq write      jumpi
    dup1 __FUNC_SIG(startLoan) eq start_loan jumpi
    dup1 __FUNC_SIG(atlas)     eq delegate   jumpi
    dup1 __FUNC_SIG(submit)    eq submit     jumpi
    dup1 __FUNC_SIG(isSolved)  eq is_solved  jumpi

    // Revert if no selectors matched
    returndatasize returndatasize revert

    borrow:
        BORROW(bubble_fail)
    enter:
        ENTER()
    write:
        WRITE(bubble_fail)
    start_loan:
        START_LOAN(bubble_fail)
    delegate:
        START_DELEGATE_CHALLENGE(bubble_fail)
    submit:
        SUBMIT_TOKENS(bubble_fail)
    is_solved:
        IS_SOLVED()
    bubble_fail:
        // Bubble up revert message from returndata (if there is any)
        returndatasize       // [returndatasize]
        dup1                 // [returndatasize, returndatasize]
        0x00 dup1            // [0x00, 0x00, returndatasize, returndatasize]
        returndatacopy       // [returndatasize]
        0x00 revert          // []
}

////////////////////////////////////////////////////////////////
///                     INTERNAL MACROS                      ///
////////////////////////////////////////////////////////////////

/// @notice Locks the transient reentrancy mutex by placing the borrower's
/// address in the slot.
/// @dev There is no need to zero-out the `MUTEX` slot because of EIP-1153!
#define macro TSTORE_BORROWER() = takes (1) {
    // Input stack:             [borrower]

    // [MUTEX] tstore
    [MUTEX] sstore

    // Return stack:            []
}

/// @notice Reverts with the `RejectBorrower(string)` error if the condition
/// is false.
///
/// SAFETY:
///  - The `msize` opcode is used to set the value for a single byte at mem[0x23].
///    This value is intended to be 0x20, so if this macro is invoked in a position
///    where `msize != 0x20`, the revert data will be malformed.
#define macro ASSERT_BORROWER() = takes (1) {
    // Input stack:          // [condition]

    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x71]
    // RejectBorrower(string)
    0x5205e60e               // [error_selector]
    0x00 mstore              // []
    msize 0x3F mstore8       // []
    [REJECT_BORROWER]        // [message]
    0x51 mstore              // []

    // Revert with custom error
    0x64 0x1C revert

    do_not_throw:

    // Return stack:            []
}

/// @notice Reverts with the `OubstandingDebt(string)` error if the condition
/// is false.
#define macro ASSERT_BALANCE() = takes (1) {
    // Input stack:          // [condition]

    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x71]
    // OutstandingDebt(string)
    0x17167f90               // [error_selector]
    0x00 mstore              // []
    0x20 dup1 mstore         // []
    [REPAY_DEBT]             // [message]
    0x50 mstore              // []

    // Revert with custom error
    0x64 0x1C revert

    do_not_throw:

    // Return stack:            []
}

/// @notice Reverts with the `ExceedsLoanThreshold()` error if the condition
/// is false.
#define macro ASSERT_LOAN_THRESHOLD() = takes (1) {
    // Input stack:          // [condition]

    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x20]
    // ExceedsLoanThreshold()
    0x12492d44               // [error_selector]
    0x00 mstore              // []

    // Revert with custom error
    0x04 0x1C revert

    do_not_throw:

    // Return stack:            []
}

/// @notice Reverts with the `NoReentrancy()` error if the condition
/// is false.
#define macro ASSERT_NO_REENTRANCY() = takes (1) {
    // Input stack:          // [condition]

    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x20]
    // NoReentrancy()
    0x583fe886               // [error_selector]
    0x00 mstore              // []

    // Revert with custom error
    0x04 0x1C revert

    do_not_throw:

    // Return stack:            []
}

/// @notice Reverts with the `ErroniousMutexUnlock()` error if the condition
/// is false.
#define macro ASSERT_NO_MUTEX_UPDATE() = takes (1) {
    // Input stack:          // [condition]

    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x20]
    // ErroniousMutexUnlock()
    0x6f490399               // [error_selector]
    0x00 mstore              // []

    // Revert with custom error
    0x04 0x1C revert

    do_not_throw:

    // Return stack:            []
}

/// @notice Reverts with the `ChallengeOver()` error if the condition
/// is false.
#define macro ASSERT_CHAL_ONGOING() = takes (1) {

    // Input stack:          // [condition]

    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x20]
    // ChallengeOver()
    0x00809489               // [error_selector]
    0x00 mstore              // []

    // Revert with custom error
    0x04 0x1C revert

    do_not_throw:

    // Return stack:            []
}

/// @notice Retrieves this address' balance of an ERC-20 compliant token
#define macro SELF_BALANCE_OF() = takes (1) returns (1) {
    // Input stack:             [token]

    __FUNC_SIG(balanceOf)    // [balanceOf_selector, token]
    returndatasize mstore    // [token]
    address 0x20 mstore      // [token]
    0x20 0x24 0x1C dup3      // [ret_size, args_offset, args_size, ret_offset, token]
    swap4 gas staticcall     // [success]

    // Return stack:            [success]
}

/// @notice Retrieves an address' balance of an ERC-20 compliant token and
/// stores it in memory @ `ptr`
#define macro BALANCE_OF(ptr) = takes (1) returns (1) {
    // Input stack:             [address, token]

    __FUNC_SIG(balanceOf)    // [balanceOf_selector, address, token]
    returndatasize mstore    // [address, token]
    0x20 mstore              // [token]
    <ptr> 0x24               // [args_size, ret_offset, token]
    0x1C 0x20                // [ret_size, args_offset, args_size, ret_offset, token]
    swap4 gas staticcall     // [success]

    // Return stack:            [success]
}

////////////////////////////////////////////////////////////////
///                     EXTERNAL MACROS                      ///
////////////////////////////////////////////////////////////////

/// @notice Start a loan callframe.
/// @param `fail` Jump label pointing to failure logic in the `MAIN` macro
#define macro START_LOAN(fail) = {
    // Do not allow reentrancy
    // TODO: Custom error
    [MUTEX] sload iszero     // [mutex == 0]
    ASSERT_NO_REENTRANCY()   // []

    // caller [MUTEX] tstore
    caller [MUTEX] sstore    // []

    // Hand control to the caller so they can start borrowing tokens
    __FUNC_SIG(bankroll)     // [bankroll_selector]
    returndatasize mstore    // []
    returndatasize           // [ret_size]
    returndatasize           // [ret_offset, ret_size]
    0x04 0x1C dup3           // [value, args_offset, args_size, ret_offset, ret_size]
    caller gas call          // [success]

    // Revert if call to flash loan receiver failed
    iszero <fail> jumpi      // []

    // TODO: tload
    timestamp sload          // [num_borrows]
    timestamp 0x01 add       // [slot_idx, num_borrows]
    debt_collector:
        // Complete loop if all `Borrow`s have been accounted for.
        // We check at the beginning of the loop rather than the end in case 0 borrows have been
        // taken out.
        dup1                 // [slot_idx, slot_idx, num_borrows]
        dup3 0x01 shl        // [num_borrows * 0x02, slot_idx, slot_idx, num_borrows]
        timestamp 0x01 add   // [timestamp + 0x01, num_borrows * 0x02, slot_idx, slot_idx, num_borrows]
        add                  // [timestamp + 0x01 + num_borrows * 0x02, slot_idx, slot_idx, num_borrows]
        eq debt_collected jumpi

        // Get the `Borrow` struct from transient storage at slot_idx
        // TODO: tload
        dup1 sload           // [init_balance, slot_idx, num_borrows]
        dup2 0x01 add sload  // [token, init_balance, slot_idx, num_borrows]

        // Get this contract's current balance of `token` and revert if the
        // `balanceOf` call fails
        SELF_BALANCE_OF()    // [success, init_balance, slot_idx, num_borrows]
        iszero <fail> jumpi  // [init_balance, slot_idx, num_borrows]

        // Assert that this contract's balance of `token` is >= to its initial balance
        0x20 mload           // [token.balanceOf(address(this)), init_balance, slot_idx, num_borrows]
        lt iszero            // [token.balanceOf(address(this)) >= init_balance, slot_idx, num_borrows]
        ASSERT_BALANCE()     // [slot_idx, num_borrows]

        // Move on to next `Borrow` slot
        0x02 add             // [slot_idx + 0x02, num_borrows]
        // Continue loop
        debt_collector jump
    debt_collected:
        stop
}

/// @notice Can be called by the current `borrower` only.
/// @param `fail` Jump label pointing to failure logic in the `MAIN` macro
/// @dev Accepts abi.encodePacked(address token, uint256 amount, address to)
/// as the calldata.
#define macro BORROW(fail) = {
    // Unpack calldata params
    0x60                     // [0x60]
    0x04 calldataload        // [cd[0x00:0x20], 0x60]
    dup2 shr                 // [token, 0x60]
    0x18 calldataload        // [amount, token, 0x60]
    0x38 calldataload        // [cd[0x4C:0x6C], amount, token, 0x60]
    dup4 shr                 // [to, amount, token, 0x60]
    swap3 pop                // [amount, token, to]

    // Ensure the loaned amount is <= MAX_BORROW
    [MAX_BORROW] dup2        // [amount, MAX_BORROW, amount, token, to]
    gt iszero                // [amount <= MAX_BORROW, amount, token, to]
    ASSERT_LOAN_THRESHOLD()  // [amount, token, to]

    // [MUTEX] tload         // [borrower, amount, token, to]
    [MUTEX] sload            // [borrower, amount, token, to]
    caller eq                // [borrower == msg.sender, amount, token, to]

    // SAFETY: `msize = 0` at this invocation every time.
    ASSERT_BORROWER()        // [amount, token, to]

    // Update number of borrows
    // TODO: tload / tstore
    timestamp sload          // [len(borrows), amount, token, to]
    dup1                     // [len(borrows), len(borrows), amount, token, to]
    0x01 add                 // [len(borrows) + 0x01, len(borrows), amount, token, to]
    timestamp sstore         // [len(borrows), amount, token, to]

    // Get the start of the next available `Borrow` slot (64 bytes each)
    0x01 shl                 // [0x02 * len(borrows), amount, token, to]
    timestamp 0x01 add add   // [0x02 * len(borrows) + timestamp + 0x01, amount, token, to]

    // Get this contract's balance of the requested token
    dup3 SELF_BALANCE_OF()   // [success, borrow_slot_start, amount, token, to]

    // Revert if `balanceOf` call failed
    // TODO: Maybe ensure the balance is > 0 too? Not really necessary, tho.
    iszero <fail> jumpi      // [borrow_slot_start, amount, token, to]

    // Store `Balance` struct in transient storage array
    // TODO: tstore
    0x20 mload               // [initial_balance, borrow_slot_start, amount, token, to]
    dup2 sstore              // [borrow_slot_start, amount, token, to]
    dup3 swap1 0x01 add      // [borrow_slot_start + 0x01, token, amount, token, to]
    sstore                   // [amount, token, to]

    // Call `transfer` on target token
    __FUNC_SIG(transfer)     // [transfer_selector, amount, token, to]
    0x00 mstore              // [amount, token, to]
    0x40 mstore              // [token, to]
    swap1 0x20 mstore        // [token]
    0x00 dup1 0x44 0x1C dup3 // [value, args_offset, args_size, ret_offset, ret_size, token]
    dup6 gas call            // [success, token]

    // Revert if `transfer` call failed
    iszero <fail> jumpi      // [token]

    stop
}

/// @notice Computes the following:
/// `keccak256(abi.encode(msg.sender, address(this)))`
/// and sets the result at the location of the mutex.
///
/// *This macro is a honeypot*
///
/// SAFETY:
/// - This is effectively a no-op. Because the `SUBMIT` macro checks if the
/// `MUTEX` slot is zero, there is no way to take advantage of this. In addition,
/// it will prevent any borrows or delegatecalls after calling.
#define macro ENTER() = {
    caller 0x00 mstore       // []
    address 0x20 mstore      // []
    0x40 0x00 sha3           // [digest]
    // tstore
    [MUTEX] sstore           // []

    stop
}

/// @notice Writes an arbitrary value to a transient storage slot that is greater
/// than any feasible timestamp. Contains some no-op code in between the check
/// to mislead the reader.
///
/// *This macro is a honeypot*
///
/// SAFETY:
/// - Because `timestamp` is used for the `borrows` array start in transient
/// storage, being able to write to any transient slot greater than `0x77359400` is 
/// safe.
#define macro WRITE(fail) = {
    0x77359400               // [0x77359400]

    // No-op code: Call the ID precompile and ignore result
    dup1 0x08 shl            // [0x77359400 << 0x08, 0x77359400]
    returndatasize mstore    // [0x77359400]
    returndatasize           // [ret_size, 0x77359400]
    returndatasize           // [ret_offset, ret_size, 0x77359400]
    msize returndatasize     // [args_offset, args_size, ret_offset, ret_size, 0x77359400]
    0x04 gas staticcall      // [success, 0x77359400]
    msize shl                // [success << msize, 0x77359400]
    pop                      // [0x77359400]

    // Load slot from calldata
    0x04 calldataload        // [slot, 0x77359400]

    // No-op code: Left 12 bytes of RipeMD hash will always be 0.
    dup1 returndatasize      // [offset, slot, slot, 0x77359400]
    mstore                   // [slot, 0x77359400]
    msize returndatasize     // [ret_offset, ret_size, slot, 0x77359400]
    msize returndatasize     // [args_offset, args_size, ret_offset, ret_size, slot, 0x77359400]
    0x03 gas staticcall      // [success, slot, 0x77359400]
    iszero <fail> jumpi      // [slot, 0x77359400]
    0x00 mload               // [hash, slot, 0x77359400]
    0xA0 shr                 // [hash >> 0xA0, slot, 0x77359400]
    <fail> jumpi             // [slot, 0x77359400]

    // Ensure that the slot passed in the first word of calldata is greater
    // than 2 billion.
    dup1 swap2               // [0x77359400, slot, slot]
    lt                       // [0x77359400 < slot, slot]
    continue jumpi           // [slot]

    // Don't let the attacker write to any transient storage slot below
    // `0x77359400`. Because `timestamp` is used for the `borrows` array
    // slot, this effectively makes this a no-op.
    returndatasize returndatasize revert
    
    continue:
        // TODO: tstore
        0x24 calldataload    // [value, slot]
        swap1                // [slot, value]
        sstore               // []

        stop
}

/// @notice Performs a delegate call to the contract in cd[0x04:0x18] if
/// cd[0x20:0x24] is equal to the last 4 bytes of the hash of the caller's
/// address.
/// @param `fail` Jump label pointing to failure logic in the `MAIN` macro
#define macro START_DELEGATE_CHALLENGE(fail) = {
    0x04 calldataload        // [cd[0x04:0x24]]
    [FOUR_BYTE_MASK] and     // [cd[0x20:0x24]]
    caller returndatasize    // [0x00, msg.sender, cd[0x20:0x24]]
    mstore                   // [cd[0x20:0x24]]
    msize returndatasize sha3// [keccak256(msg.sender), cd[0x20:0x24]]
    [FOUR_BYTE_MASK] and eq  // [keccak256(msg.sender)[0x1C:0x20] == cd[0x20:0x24]]
    continue jumpi

    returndatasize           // [0x00]
    returndatasize revert    // []

    continue:
    PERFORM_DELEGATE_CALL(<fail>)
}

/// @notice Performs a delegate call to a specific contract
/// @param `fail` Jump label pointing to failure logic in the `MAIN` macro
#define macro PERFORM_DELEGATE_CALL(fail) = {
    // Ensure that the calling address is the current transient borrower
    // TODO: tload
    [MUTEX] sload            // [mutex]
    dup1                     // [mutex, mutex]
    caller eq                // [mutex == caller, mutex]
    ASSERT_BORROWER()        // [mutex]

    0x04 calldataload        // [address << 0x60, mutex]
    0x60 shr                 // [address, mutex]

    returndatasize           // [0x00, address, mutex]
    returndatasize           // [0x00, 0x00, address, mutex]
    returndatasize           // [0x00, 0x00, 0x00, address, mutex]
    returndatasize           // [0x00, 0x00, 0x00, 0x00, address, mutex]
    swap4                    // [address, 0x00, 0x00, 0x00, 0x00, mutex]
    // TODO: Determine exact gas limit for the delegate call + 2 push ops and a tstore
    // It's super important that we update this value before deployment- otherwise,
    // attackers will be able to update persistent storage here.
    0x1000                   // [gas, address, 0x00, 0x00, 0x00, 0x00, mutex]
    delegatecall             // [success, mutex]
    iszero <fail> jumpi      // [mutex]

    // Ensure that the mutex was not updated by the delegate call!
    // This is to prevent people from calling `submit` with loaned funds- they
    // must own them outright.
    // TODO: tload
    [MUTEX] sload eq         // [mutex == mutex]
    ASSERT_NO_MUTEX_UPDATE() // []

    stop
}

/// @notice Submit your entire balance of the mock ERC-20 token to receive an award
/// @param `fail` Jump label pointing to failure logic in the `MAIN` macro
#define macro SUBMIT_TOKENS(fail) = {
    timestamp [END] gt       // [end_date > now]
    ASSERT_CHAL_ONGOING()    // []

    // Ensure there is no outstanding loan
    [MUTEX] sload iszero     // [mutex == 0]
    ASSERT_BALANCE()         // []

    // Get the caller's balance of the token and construct `transferFrom` params
    [TOKEN] caller           // [msg.sender, token]
    BALANCE_OF(0x60)         // [success]
    iszero <fail> jumpi      // []

    __FUNC_SIG(transferFrom) // [transferFrom_sig]
    0x00 mstore              // []
    caller 0x20 mstore       // []
    address 0x40 mstore      // []

    // Pull the caller's tokens back into this contract
    0x20 0x00 0x64 0x1C dup3 // [value, args_offset, args_size, ret_offset, ret_size]
    [TOKEN] gas call         // [success]
    iszero <fail> jumpi      // []

    // Get the persistent storage slot for the caller
    // Rarely seen use of `true`/`false` keywords in Huff o.e
    true                     // [0x01]
    origin 0x00 mstore       // [0x01]
    0x20 0x00 sha3           // [keccak256(msg.sender), 0x01]
    sstore                   // []

    // Emit the `ChallengeSolved` event for indexing
    origin                   // []
    __EVENT_HASH(ChallengeSolved)
    0x00 dup1 log2           // []

    stop
}

/// @notice Check whether or not your EOA has solved the challenge
#define macro IS_SOLVED() = {
    caller returndatasize    // [0x00, caller]
    mstore                   // []
    0x20 0x00 sha3           // [keccak256(msg.sender)]

    sload                    // [has_solved]
    0x00 mstore              // []
    0x20 0x00 return
}
