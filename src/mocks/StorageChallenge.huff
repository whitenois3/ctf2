/// @notice Challenge with storage instead of transient for foundry testing
/// @notice SPDX-License-Identifier: MIT
/// @author clabby <https://github.com/clabby>
/// @author asnared <https://github.com/abigger87>

// Imports
#include "huffmate/utils/CommonErrors.huff"
#include "huffmate/auth/NonPayable.huff"
#include "huffmate/data-structures/Hashmap.huff"

// ERC20 Interface
#define function approve(address,uint256) nonpayable returns ()
#define function allowance(address,address) view returns (uint256)
#define function permit(address,address,uint256,uint256,uint8,bytes32,bytes32) nonpayable returns ()

#define function DOMAIN_SEPARATOR() view returns (bytes32)
#define function nonces(address) view returns (uint256)

#define function balanceOf(address) view returns (uint256)
#define function totalSupply() view returns (uint256)

#define function transfer(address to, uint256 amount) nonpayable returns (bool)
#define function transferFrom(address from, address to, uint256 amount) nonpayable returns (bool)

#define function decimals() nonpayable returns (uint256)
#define function name() nonpayable returns (string)
#define function symbol() nonpayable returns (string)

// Custom Warden functions
#define function toggle() nonpayable returns ()
#define function frozen() view returns (bool)
#define function warden() nonpayable returns (address)

// Custom Harvesting Functions
#define function harvest(address) nonpayable returns ()
#define function harvestable(address) view returns (uint256)

// Events
#define event Approval(address indexed, address indexed, uint256)
#define event Transfer(address, address, uint256)

// "Whitenois3"
#define constant META_NAME = 0x57686974656e6f69733300000000000000000000000000000000000000000000
#define constant META_NAME_LENGTH = 0x0a

// "WHTN"
#define constant META_SYMBOL = 0x5748544e00000000000000000000000000000000000000000000000000000000
#define constant META_SYMBOL_LENGTH = 0x04

// "FROZEN"
#define constant FROZEN_MESSAGE = 0x46524f5a454e0000000000000000000000000000000000000000000000000000
#define constant FROZEN_MESSAGE_LENGTH = 0x06

// "MAX_SUPPLY"
#define constant MAX_SUPPLY_ERROR = 0x4d41585f535550504c5900000000000000000000000000000000000000000000
#define constant MAX_SUPPLY_LENGTH = 0x0a

// The maximum supply is 10 * the initial total supply
#define constant MAX_SUPPLY = 0x1000000

// Storage
#define constant WARDEN = FREE_STORAGE_POINTER()
#define constant FROZEN = FREE_STORAGE_POINTER()
#define constant TOTAL_SUPPLY_SLOT = FREE_STORAGE_POINTER()
#define constant BALANCE_SLOT = FREE_STORAGE_POINTER()
#define constant APPROVAL_SLOT = FREE_STORAGE_POINTER()
#define constant DECIMALS_SLOT = FREE_STORAGE_POINTER()

// Compounding Interest
#define constant LAST_HARVEST_TIME = FREE_STORAGE_POINTER()
#define constant LAST_HARVEST_AMOUNT = FREE_STORAGE_POINTER()

// EIP-2612 STORAGE
#define constant INITIAL_CHAIN_ID = FREE_STORAGE_POINTER()
#define constant INITIAL_DOMAIN_SEPARATOR = FREE_STORAGE_POINTER()
#define constant NONCE_SLOT = FREE_STORAGE_POINTER()

// PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")
#define constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9
#define constant X_1901 = 0x1901000000000000000000000000000000000000000000000000000000000000

// Utility Constants
#define constant UINT_256_MAX = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
#define constant ERROR_SIG = 0x08c379a000000000000000000000000000000000000000000000000000000000
#define constant ZERO_ADDRESS = 0x0000000000000000000000000000000000000000



// TransientLoan.huff
#define function startLoan() nonpayable returns ()
#define function borrow(address from, uint256 amount, address to) nonpayable returns ()

// IFlashLoanReceiver.sol
#define function bankroll() nonpayable returns ()

/// @notice Transient storage slot for the reentrancy mutex
#define constant MUTEX = FREE_STORAGE_POINTER()

/// @notice The slot for the length of the `borrows` array in transient storage
/// @dev The `borrows` array contains elements that are 64 bytes in size. The first
/// slot begins at this value + 1.
#define constant BORROWS = FREE_STORAGE_POINTER()

/// @notice "Not the borrower!" string.
/// @dev The length of the string (17 bytes) is prepended to the contents of the string.
/// Store at 1 byte before the desired destination of the string contents in memory.
#define constant REJECT_BORROWER = 0x114e6f742074686520626f72726f77657221

/// @notice "Repay your debt!" string.
/// @dev The length of the string (16 bytes) is prepended to the contents of the string.
/// Store at 1 byte before the desired destination of the string contents in memory.
#define constant REPAY_DEBT = 0x10526570617920796f7572206465627421

/// @notice TransientLoan Dispatcher
#define macro TRANSIENT_LOAN_MAIN() = takes (1) returns (1) {
    // Input Stack: [selector]
    // Output Stack: [selector]

    dup1 __FUNC_SIG(borrow)    eq borrow     jumpi      // [selector]
    dup1 __FUNC_SIG(startLoan) eq start_loan jumpi      // [selector]

    // Bubble up to parent if no function selector matches
    bubble_up jump                                      // []

    borrow:
        BORROW(fail)
    start_loan:
        START_LOAN(fail)
    fail:
        // Bubble up revert message from call (if there is any)
        returndatasize                                  // [returndatasize]
        dup1                                            // [returndatasize, returndatasize]
        0x00 dup1                                       // [0x00, 0x00, returndatasize, returndatasize]
        returndatacopy                                  // [returndatasize]
        0x00 revert                                     // []

    bubble_up:
}

/// @notice Locks the transient reentrancy mutex by placing the borrower's address in the slot.
/// @dev There is no need to zero-out the `MUTEX` slot because of EIP-1153!
#define macro TSTORE_BORROWER() = takes (1) {
    // Input stack:             [borrower]
    // Output stack:            []
    [MUTEX] sstore
}

/// @notice Reverts with the `RejectBorrower(string)` error if the condition
/// is false.
///
/// SAFETY:
///  - The `msize` opcode is used to set the value for a single byte at mem[0x23].
///    This value is intended to be 0x20, so if this macro is invoked in a position
///    where `msize != 0x20`, the revert data will be malformed.
#define macro ASSERT_BORROWER() = takes (1) {
    // Input stack:             [condition]
    // Output stack:            []

    // Check if the input condition holds
    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x71]
    // RejectBorrower(string)
    0x5205e60e               // [error_selector]
    0x00 mstore              // []
    msize 0x3F mstore8       // []
    [REJECT_BORROWER]        // [message]
    0x51 mstore              // []

    // Revert with custom error
    0x55 0x1C revert

    do_not_throw:
}

/// @notice Reverts with `OubstandingDebt(string)` if the condition is false.
#define macro ASSERT_BALANCE() = takes (1) {
    // Input stack:             [condition]
    // Output stack:            []

    // Check the condition
    do_not_throw jumpi       // []

    // Store error selector and revert string in mem[0x1C:0x71]
    // OutstandingDebt(string)
    0x17167f90               // [error_selector]
    0x00 mstore              // []
    0x20 dup1 mstore         // []
    [REPAY_DEBT]             // [message]
    0x50 mstore              // []

    // Revert with custom error
    0x64 0x1C revert

    do_not_throw:
}

/// @notice Retrieves an address' balance of an ERC-20 compliant token
#define macro _BALANCE_OF() = takes (1) returns (1) {
    // Input stack:                                    [account]
    [BALANCE_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)     // [balance]
}


/// @notice Start a loan callframe.
/// @param `fail` Jump label pointing to failure logic in the `MAIN` macro
#define macro START_LOAN(fail) = {
    // Transcend the caller as the `borrower`
    caller [MUTEX] sstore    // []

    // Hand control to the caller so they can start borrowing tokens
    __FUNC_SIG(bankroll)     // [bankroll_selector]
    0x00 mstore              // []
    0x00 dup1 0x04 0x1C dup3 // [value, args_offset, args_size, ret_offset, ret_size]
    caller gas call          // [success]

    dup1 __EVENT_HASH(LogWord) 0x00 dup1 log2

    // Revert if call to flash loan receiver failed
    iszero <fail> jumpi      // []

    // Load the number of borrowers
    [BORROWS] sload          // [num_borrows]
    0x00                     // [idx, num_borrows]

    // Complete loop if all `Borrow`s have been accounted for.
    // We check at the beginning of the loop in case 0 borrows have been made.
    debt_collector:
        dup1 [BORROWS] LOAD_ELEMENT_FROM_KEYS(0x00)   // [borrows[i], idx, num_borrows]

        eq debt_collected jumpi

        // Get the `Borrow` struct from transient storage at slot_idx
        dup1 sload           // [init_balance, slot_idx, num_borrows]
        dup2 0x01 add sload  // [from, init_balance, slot_idx, num_borrows]

        // Assert that the from balance is >= to its initial balance
        _BALANCE_OF()        // [balance, init_balance, slot_idx, num_borrows]
        swap1 lt             // [init_balance <= balance, slot_idx, num_borrows]
        ASSERT_BALANCE()     // [slot_idx, num_borrows]

        // Move on to next `Borrow` slot
        0x02 add             // [slot_idx + 0x02, num_borrows]
        debt_collector jump

    debt_collected:
        stop
}

#define event LogWord(bytes32)

/// @notice Can be called by the current `borrower` only.
/// @param `fail` Jump label pointing to failure logic in the `MAIN` macro
#define macro BORROW(fail) = {
    // Unpack calldata params
    0x04 calldataload        // [from]
    0x24 calldataload        // [amount, from]
    0x44 calldataload        // [to, amount, from]

    // Check that the caller is the current transient `borrower`
    [MUTEX] sload            // [borrower, to, amount, from]
    caller eq                // [borrower == msg.sender, to, amount, from]

    // SAFETY: `msize = 0` at this invocation every time.
    ASSERT_BORROWER()        // [to, amount, from]

    // Update number of borrows
    [BORROWS] sload          // [len(borrows), to, amount, from]
    dup1                     // [len(borrows), len(borrows), to, amount, from]
    0x01 add                 // [len(borrows) + 0x01, len(borrows), to, amount, from]
    [BORROWS] sstore         // [len(borrows), to, amount, from]

    // Get the start of the next available `Borrow` slot (64 bytes each)
    [BORROWS] LOAD_ELEMENT_FROM_KEYS(0x00) // [slot, to, amount, from]

    // Get this contract's balance of the requested token
    dup4 _BALANCE_OF()       // [balance, borrow_slot_start, to, amount, from]

    // Store `Borrow` struct in transient storage array
    dup2 sstore              // [borrow_slot_start, to, amount, from]
    dup4 swap1 0x20 add sstore        // [to, amount, from]
    // NOTE: we don't need to store the `token` address in storage because it is address(this)

    // Call `transfer` on target token
    // Transfer - takes:        [value, from, to]
    swap2 swap1              // [amount, from, to]
    _INTERNAL_TRANSFER()     // [amount, from, to]

    stop
}


/// @notice Constructor
/// @notice Sets the initial domain separator and chain ID
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy the decimals into memory from the bytecode
    0x20                                    // [size] - byte size to copy
    0x40 codesize sub                       // [offset, size] - offset in the code to copy from
    0x00                                    // [mem, offset, size] - offset in memory to copy to
    codecopy                                // []

    // Copy the decimals from memory into the DECIMALS_SLOT storage location
    0x00 mload                              // [decimals]
    [DECIMALS_SLOT] sstore                  // []

    // Copy the warden into memory from the bytecode
    0x20                                    // [size] - byte size to copy
    0x20 codesize sub                       // [offset, size] - offset in the code to copy from
    0x00                                    // [mem, offset, size] - offset in memory to copy to
    codecopy                                // []

    // Save the caller as the warden
    0x00 mload dup1                         // [warden, warden]
    [WARDEN] sstore                         // [warden]

    // Mint the warden an initial supply
    0x100000                                // [amount, to]
    _MINT()                                 // []

    chainid [INITIAL_CHAIN_ID] sstore       // []
    COMPUTE_DOMAIN_SEPARATOR()              // [DOMAIN SEPARATOR]
    [INITIAL_DOMAIN_SEPARATOR] sstore       // []
}

/// @notice Toggle
/// @notice Allows the warden to freeze transfers
#define macro TOGGLE() = takes (0) returns (0) {
    // Ensure the caller is the warden
    [WARDEN] sload                          // [warden]
    caller eq warden_authed jumpi           // [isWarden]
    UNAUTHORIZED(0x00)                      // _reverts_

    warden_authed:

    // Toggle the frozen state
    [FROZEN] sload                         // [frozen]
    iszero                                 // [!frozen]
    [FROZEN] sstore                        // []
}

/// @notice Returns if the contract is frozen
#define macro GET_FROZEN() = {
    [FROZEN] sload                         // [frozen]
    0x00 mstore
    0x20 0x00 return
}

/// @notice Reverts with an "ZERO_ADDRESS" message if the condition is false
#define macro ZERO_ADDRESS(condition) = takes (0) returns (0) {
    [ZERO_ADDRESS_ERROR]            // ["ZERO_ADDRESS"]
    [ZERO_ADDRESS_LENGTH]           // [12 (length), "ZERO_ADDRESS"]
    <condition>                     // [condition, 12 (length), "ZERO_ADDRESS"]
    REQUIRE()                       // []
}

/// @notice Not Frozen
/// @notice Reverts if the contract is frozen
#define macro NOT_FROZEN() = takes (0) returns (0) {
    [FROZEN] sload                          // [frozen]
    iszero not_frozen jumpi                 // []
        [FROZEN_MESSAGE]                    // ["FROZEN"]
        [FROZEN_MESSAGE_LENGTH]             // [6 (length), "FROZEN"]
        0x00 REQUIRE()                      // _reverts_
    not_frozen:
}

/// @notice Approve
/// @notice Grants approval to an operator to transfer tokens on behalf of the sender.
#define macro APPROVE() = takes (0) returns (0) {
    NON_PAYABLE()                           // []

    0x24 calldataload                       // [value]
    0x04 calldataload                       // [to, value]
    caller                                  // [from, to, value]
    [APPROVAL_SLOT]                         // [slot, from, to, value]
    STORE_ELEMENT_FROM_KEYS_2D(0x00)        // []

    // Emit the Approval event
    0x24 calldataload                       // [value]
    0x00 mstore                             // []
    0x04 calldataload                       // [to]
    caller                                  // [from, to]
    __EVENT_HASH(Approval)                  // [sig, from, to]
    0x20 0x00                               // [0, 32, sig, from, to]
    log3                                    // []

    // Return 01 for true
    0x01 0x00 mstore                        // []
    0x20 0x00 return                        // []
}

/// @notice Transfer
/// @notice Non-Payable function that transfers an amount of tokens from the sender to a recipient.
#define macro TRANSFER() = takes (0) returns (0) {
    NON_PAYABLE()                           // []
    NOT_FROZEN()                            // []

    // Setup the stack for the transfer function.
    0x04 calldataload                       // [to]
    caller                                  // [from, to]
    0x24 calldataload                       // [value, from, to]

    _INTERNAL_TRANSFER()                    // []

    // Return "1" to represent a succesful transfer.
    0x01 0x00 mstore                        // []
    0x20 0x00 return                        // []
}

/// @notice Transfer From
/// @notice Non-Payable function that transfers an amount of tokens from an address to a recipient.
#define macro TRANSFER_FROM() = takes (0) returns (0) {
    NON_PAYABLE()                           // []
    NOT_FROZEN()                            // []

    // Setup the stack for the transfer function.
    0x24 calldataload                       // [to]
    0x04 calldataload                       // [from, to]
    caller                                  // [msg.sender, from, to]
    dup2                                    // [from, msg.sender, from, to]
    [APPROVAL_SLOT]                         // [slot, from, msg.sender, from, to]

    // Check for max approval
    LOAD_ELEMENT_FROM_KEYS_2D(0x00)         // [approved, from, to]
    dup1                                    // [approved, approved, from, to]
    0x44 calldataload                       // [value, approved, approved, from, to]

    // Check isOwner
    dup4                                    // [from, value, approved, approved, from, to]
    caller                                  // [msg.sender, from, value, approved, approved, from, to]
    eq                                      // [msg.sender == from, value, approved, approved, from, to]
    approved1 jumpi                         // [value, approved, approved, from, to]

    // Check max approval
    dup2                                    // [approved, value, approved, approved, from, to]
    [UINT_256_MAX]                          // [type(uint).max, approved, value, approved, approved, from, to]
    eq                                      // [type(uint).max == approved, value, approved, approved, from, to]
    approved1 jumpi                         // [value, approved, approved, from, to]

    // Check has approval
    gt                                      // [value > approved, approved, from, to]
    insufficientApproval jumpi              // [approved, from, to]

    // Adjust approval
    0x44 calldataload                       // [value, approved, from, to]
    swap1                                   // [approved, value, from, to]
    sub                                     // [approved - value => newApprovalValue, from, to]
    caller                                  // [msg.sender, newApprovalValue, from, to]
    dup3                                    // [from, msg.sender, newApprovalValue, from, to]
    [APPROVAL_SLOT]                         // [slot, from, msg.sender, newApprovalValue, from, to]
    STORE_ELEMENT_FROM_KEYS_2D(0x00)        // [from, to]
    approved2 jump                          // [from, to]

    approved1:                              // [value, approved, approved, from, to]
        pop pop pop                         // [from, to]

    approved2:                              // [from, to]
        0x44 calldataload                   // [value, from, to]

        _INTERNAL_TRANSFER()                // []

        // Return "1" to represent a succesful transfer.
        0x01 0x00 mstore                    // []
        0x20 0x00 return                    // []

    insufficientApproval:
        0x00 0x00 revert                    // []
}

/// @notice Get the amount of tokens an account can harvest
#define macro HARVESTABLE() = {
    0x04 calldataload                   // [account]
    _HARVESTABLE()                      // [amount]
    0x00 mstore                         // []
    0x20 0x00 return                    // _returns_
}

/// @notice Internal helper to get the amount harvestable by an account
#define macro _HARVESTABLE() = takes (1) returns (1) {
    // Input Stack: [account]
    // Output Stack: [amount]

    // Get the last harvest time
    dup1 [LAST_HARVEST_TIME]            // [slot, account, account]
    LOAD_ELEMENT_FROM_KEYS(0x00)        // [lastHarvestTime, account]

    // Return 0 if the harvest time is zero
    dup1 iszero no_harvest jumpi        // [lastHarvestTime, account]

    // Subtract the last harvest time from now
    timestamp sub                       // [timeSinceLastHarvest, account]

    // Divide the time period by the number of periods
    // One period = a day = 24 hours = 86400 seconds = 0x15180
    0x15180 swap1 div                   // [timeSinceLastHarvest / 24 hours, account]

    // Get the balance of the account
    dup2 [BALANCE_SLOT]                 // [slot, account, periodsSinceLastHarvest, account]
    LOAD_ELEMENT_FROM_KEYS(0x00)        // [balance, periodsSinceLastHarvest, account]

    // Calculate the harvestable amount(balance * periodsSinceLastHarvest) / MAX_SUPPLY
    mul [MAX_SUPPLY] swap1 div          // [amount, account]
    good_harvest jump

    no_harvest:
        pop pop 0x00                    // [0x00]

    good_harvest:
}

/// @notice Harvests interest for an account
#define macro HARVEST() = {
    0x04 calldataload                   // [account]
    _INTERNAL_HARVEST()                 // []
    stop
}

/// @notice Internal helper to havest a user's interest
#define macro _INTERNAL_HARVEST() = takes (1) returns (0) {
    // Input Stack: [account]

    // Get the last harvest time
    dup1 [LAST_HARVEST_TIME]            // [slot, account, account]
    LOAD_ELEMENT_FROM_KEYS(0x00)        // [lastHarvestTime, account]

    // If the harvest time is zero, set to now and finish harvesting
    iszero set_now jumpi                // [account]

    // Get the harvestable ammount
    dup1 _HARVESTABLE()                 // [amount, account]

    // Mint `amount` to `account`
    dup2 swap1 _INTERNAL_MINT()         // [account]

    // Update the harvest
    timestamp swap1                     // [account, timestamp]
    [LAST_HARVEST_TIME]                 // [slot, account, timestamp]
    STORE_ELEMENT_FROM_KEYS(0x00)       // []
    harvested jump                      // []

    set_now:
        timestamp dup2                  // [account, timestamp, account]
        [LAST_HARVEST_TIME]             // [slot, account, timestamp, account]
        STORE_ELEMENT_FROM_KEYS(0x00)   // [account]
        pop                             // []
    harvested:
}

/// @notice Internal Transfer
#define macro _INTERNAL_TRANSFER() = takes (3) returns (0) {
    // Input Stack:                     // [value, from, to]

    // Automatically harvest the user's amount
    dup2 _INTERNAL_HARVEST()            // [value, from, to]

    // Update the balances of the sender and recipient.
    _TRANSFER_TAKE_FROM()               // [value, from, to]
    _TRANSFER_GIVE_TO()                 // [value, from, to]

    // Emit the transfer event.
    0x00 mstore                         // [from, to]
    __EVENT_HASH(Transfer)              // [sig, from, to]
    0x20 0x00                           // [0, 32, sig, from, to]
    log3                                // []
}

/// @notice Transfers an amount of tokens from
#define macro _TRANSFER_TAKE_FROM() = takes (3) returns (3) {
    // input stack: [value, from, to]
    dup2 [BALANCE_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)        // [balance, value, from, to]                                                // [from, value, from, to]
    dup1                                                    // [balance, balance, value, from, to]
    dup3                                                    // [value, balance, balance, value, from, to]
    gt                                                      // [value > balance, balance, value, from, to]
    iszero                                                  // [value <= balance, balance, value, from, to]
    valid jumpi                                             // [balance, value, from, to]

    // Insufficient balance
    0x00 0x00 revert                                        // []

    // Update the sender's balance.
    valid:
        dup2                                                // [value, balance, value, from, to]
        swap1                                               // [balance, value, value, from, to]
        sub                                                 // [balance - value, value, from, to]
        dup3                                                // [from, balance - value, value, from, to]
        [BALANCE_SLOT] STORE_ELEMENT_FROM_KEYS(0x00)        // [value, from, to]
}

/// @notice Transfers an amount of tokens from one address to another.
#define macro _TRANSFER_GIVE_TO() = takes (3) returns (3) {
    // input stack: [value, from, to]
    dup3                                                // [to, value, from, to]
    dup2                                                // [value, to, value, from, to]
    swap1                                               // [to, value, value, from, to]
    [BALANCE_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)         // [balance, value, value, from, to]
    add                                                 // [balance + value, value, from, to]
    dup4                                                // [to, balance + value, value, from, to]
    [BALANCE_SLOT] STORE_ELEMENT_FROM_KEYS(0x00)        // [value, from, to]
}

/// @notice Approve
/// @notice Approves an address to spend an amount of tokens on the caller's behalf
#define macro APPROVE() = takes (0) returns (0) {
    0x24 calldataload                           // [value]
    dup1 0x00 mstore                            // [value]
    0x04 calldataload                           // [to, value]
    caller                                      // [from, to, value]

    // Emit the approval event.
    dup2 dup2                                   // [from, to, from, to, value]
    __EVENT_HASH(APPROVAL_EVENT_SIGNATURE)      // [sig, from, to, from, to, value]
    0x20 0x00                                   // [0, 32, sig, from, to, from, to, value]
    log3                                        // [from, to, value]

    // Store the value at slot = keccak256(from . to)
    STORE_ELEMENT_FROM_KEYS(0x00)
}

/// @notice Domain Separator
/// @notice Returns the EIP-712 domain separator
#define macro DOMAIN_SEPARATOR() = takes (0) returns (0) {
    NON_PAYABLE()                   // []
    _DOMAIN_SEPARATOR()             // [domain separator]
    0x00 mstore                     // [domain separator]
    0x20 0x00 return                // []
}

/// @notice Loads the EIP-712 domain separator
#define macro _DOMAIN_SEPARATOR() = takes (0) returns (1) {
    chainid                                     // [chainid]
    [INITIAL_CHAIN_ID] sload                    // [INITIAL_CHAIN_ID, chainid]
    eq                                          // [INITIAL_CHAIN_ID == chainid]
    useInitial jumpi                            // []
    COMPUTE_DOMAIN_SEPARATOR()                  // [computed domain separator]
    done jump

    useInitial:
        [INITIAL_DOMAIN_SEPARATOR] sload        // [INITIAL_DOMAIN_SEPARATOR]

    done:
}

/// @notice Computes the EIP-712 domain separator
#define macro COMPUTE_DOMAIN_SEPARATOR() = takes (0) returns (1) {
    // WARNING: 0x00 - 0x3f (64 bytes): scratch space for hashing methods
    // AS SUCH, WE STORE VARIABLES IN MEMORY STARTING AT 0x40
    [PERMIT_TYPEHASH] 0x40 mstore   // []
    [META_NAME] 0x60 mstore         // []
    0x20 0x60 sha3 0x60 mstore      // []

    // 0x31 is hex for ascii for 1
    0x31 0x80 mstore                // []
    0x02 0x80 sha3 0x80 mstore      // [hash of "1"]

    chainid 0xa0 mstore             // [chainid]
    address 0xc0 mstore             // [address(this)]

    0xA0 0x40 sha3                  // [hash]
}


/// @notice Permit
/// @notice EIP 2612 Signed Approvals
#define macro PERMIT() = takes (0) returns (0) {
    NON_PAYABLE()
    // function permit arg    calldata loc
    //     address owner         0x04
    //     address spender       0x24
    //     uint256 value         0x44
    //     uint256 deadline      0x64
    //     uint8 v               0x84
    //     bytes32 r             0xa4
    //     bytes32 s             0xc4

    // check deadline
    0x64 calldataload                       // [deadline]
    dup1                                    // [deadline, deadline]
    timestamp                               // [timestamp, deadline, deadline]
    gt                                      // [timestamp > deadline, deadline]
    expired jumpi                           // [deadline]

    // Calculate inner keccak
    // keccak256(
    //      abi.encode(
    //        PERMIT_TYPEHASH,
    //        owner,
    //        spender,
    //        value,
    //        nonces[owner]++,
    //        deadline
    //      )
    // )
    0x04 calldataload                       // [owner, deadline]
    _NONCE_PLUS_PLUS()                      // [nonce, deadline]
    0x44 calldataload                       // [value, nonce, deadline]
    0x24 calldataload                       // [spender, value, nonce, deadline]
    0x04 calldataload                       // [owner, spender, value, nonce, deadline]
    [PERMIT_TYPEHASH]                       // [permit hash, owner, spender, value, nonce, deadline]
    0x00 mstore                             // [owner, spender, value, nonce, deadline]
    0x20 mstore                             // [spender, value, nonce, deadline]
    0x40 mstore                             // [value, nonce, deadline]
    0x60 mstore                             // [nonce, deadline]
    0x80 mstore                             // [deadline]
    0xa0 mstore                             // []
    0xc0 0x00                               // [loc, len]
    sha3                                    // [inner hash]

    // Grab the domain separator
    _DOMAIN_SEPARATOR()                     // [domain separator, inner hash]
    [X_1901]                                // [x1901, domain separator, inner hash]

    // Bitwise shifts
    dup3 0xf0 shl                           // [inner hash << 0xf0, x1901, domain separator, inner hash]

    // Create the second word
    dup3 0xf0 shl                           // [domain separator << 0xf0, inner hash << 0xf0, x1901, domain separator, inner hash]
    dup5 0x10 shr or                        // [domain separator << 0xf0 | inner hash >> 0x10, inner hash << 0xf0, x1901, domain separator, inner hash]

    // Create the first word
    dup4 dup4 swap1 0x10 shr or             // [x1901 | domain separator >> 0x10, domain separator << 0xf0 | inner hash >> 0x10, inner hash << 0xf0, x1901, domain separator, inner hash]

    // Prepare memory mstore outer keccak
    0x40 mstore                             // [domain separator << 0xf0 | inner hash >> 0x10, inner hash << 0xf0, x1901, domain separator, inner hash]
    0x60 mstore                             // [inner hash << 0xf0, x1901, domain separator, inner hash]
    0x80 mstore                             // [x1901, domain separator, inner hash]
    0x42 0x40                               // [loc, len, x1901, domain separator, inner hash]
    sha3                                    // [outer hash, x1901, domain separator, inner hash]

    // Store signature in memory                                 memory layout:
    0x00 mstore                             // []                0x00 outer hash
    0x84 calldataload                       // [v]
    0x20 mstore                             // []                0x00 outerhash 0x20 v
    0xa4 calldataload                       // [r]
    0x40 mstore                             // []                0x00 outerhash 0x20 v 0x40 r
    0xc4 calldataload                       // [s]
    0x60 mstore                             // []                0x00 outerhash 0x20 v 0x40 r 0x60 s

    // Prepare stack for later
    0x44 calldataload                       // [value]
    0x24 calldataload                       // [spender, value]

    // ecrecover
    0x20                                    // [32, spender, value]
    0x80                                    // [128, 32, spender, value]
    0x80                                    // [128, 128, 32, spender, value]
    0x00                                    // [0, 128, 128, 32, spender, value]
    0x1                                     // [ecrecover precompile address, 0, 128, 128, 32, spender, value]
    0xFFFFFFFF                              // [gas, ecrecover precompile address, 0, 128, 128, 32, spender, value]
    staticcall                              // [success, spender, value]

    // Revert invalid signer if call failed
    iszero invalidSigner jumpi              // [spender, value]

    // Load the recovered address from memory
    0x80 mload                              // [recovered address, spender, value]

    // check for recovered 0 address
    dup1                                    // [recovered address, recovered address, spender, value]
    0x00 eq                                 // [recovered address == 0, recovered address, spender, value]
    invalidSigner jumpi                     // [recovered address, spender, value]

    // check for address is owner
    dup1                                    // [recovered address, recovered address, spender, value]
    0x04 calldataload                       // [owner, recovered address, recovered address, spender, value]
    eq                                      // [owner == recovered address, recovered address, spender, value]
    iszero                                  // [owner != recovered address, recovered address, spender, value]
    invalidSigner jumpi                     // [recovered address, spender, value]
    [APPROVAL_SLOT]                         // [slot, recovered address, spender, value]
    STORE_ELEMENT_FROM_KEYS_2D(0x00)        // []

    // Emit the Approval event
    0x44 calldataload                       // [value]
    0x00 mstore                             // []
    0x24 calldataload                       // [to]
    0x04 calldataload                       // [from, to]
    __EVENT_HASH(Approval)                  // [sig, from, to]
    0x20 0x00                               // [0, 32, sig, from, to]
    log3                                    // []

    // Stop Execution
    stop                                    // []

    expired:
        0x5045524D49545F444541444C494E455F45585049524544000000000000000000         // ["PERMIT_DEADLINE_EXPIRED"]
        0x17                                                                       // [23 (length), "PERMIT_DEADLINE_EXPIRED"]
        0x00                                                                       // [0, 23 (length), "PERMIT_DEADLINE_EXPIRED"]
        REQUIRE()

    invalidSigner:
        0x494E56414C49445F5349474E4552000000000000000000000000000000000000         // ["INVALID_SIGNER"]
        0x0e                                                                       // [14 (length), "INVALID_SIGNER"]
        0x00                                                                       // [0, 14 (length), "INVALID_SIGNER"]
        REQUIRE()
}

/// @notice Takes an address off the stack, returns the current nonce for that address onto the stack.
/// @notice Increments the nonce for next time,
#define macro _NONCE_PLUS_PLUS() = takes (1) returns (1) {
    // input stack                                  // [account]
    dup1                                            // [account, account]
    [NONCE_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)       // [currentNonce, account]
    dup1                                            // [currentNonce, currentNonce, account]
    0x01                                            // [1, currentNonce, currentNonce, account]
    add                                             // [nextNonce, currentNonce, account]
    dup3                                            // [account, nextNonce, currentNonce, account]
    [NONCE_SLOT] STORE_ELEMENT_FROM_KEYS(0x00)      // [currentNonce, account]
    swap1 // clean up stack                         // [account, currentNonce]
    pop   // clean up stack                         // [currentNonce]
}

/// @notice Nonces
/// @notice Returns the current nonce for an account
#define macro NONCES() = takes (0) returns (0) {
    0x04 calldataload                               // [account]
    [NONCE_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)       // [nonce]
    0x00 mstore                                     // []
    0x20 0x00 return                                // []
}

/// @notice Name
/// @notice Returns the token name string
#define macro NAME() = takes (0) returns (0) {
    NON_PAYABLE()                       // []
    0x20 0x00 mstore                    // []
    [META_NAME_LENGTH] 0x20 mstore      // []
    [META_NAME] 0x40 mstore             // []
    0x60 0x00 return                    // []
}

/// @notice Warden
/// @notice Returns the configured warden
#define macro GET_WARDEN() = takes (0) returns (0) {
    NON_PAYABLE()                       // []
    [WARDEN] sload 0x00 mstore          // []
    0x20 0x00 return                    // []
}


/// @notice Symbol
/// @notice Returns the symbol of the token
#define macro SYMBOL() = takes (0) returns (0) {
    NON_PAYABLE()                       // []
    0x20 0x00 mstore                    // []
    [META_SYMBOL_LENGTH] 0x20 mstore    // []
    [META_SYMBOL] 0x40 mstore           // []
    0x60 0x00 return                    // []
}

/// @notice Decimals
/// @notice Returns the token decimal representation
#define macro DECIMALS() = takes (0) returns (0) {
    NON_PAYABLE()                       // []
    [DECIMALS_SLOT] sload               // [decimals]
    0x00 mstore                         // []
    0x20 0x00 return                    // []
}

/// @notice Balance Of
/// @notice Returns the token balance of an address
#define macro BALANCE_OF() = takes (0) returns (0) {
    NON_PAYABLE()                                   // []
    0x04 calldataload                               // [account]
    [BALANCE_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)     // [balance]
    0x00 mstore                                     // []
    0x20 0x00 return                                // []
}

/// @notice Total Supply
/// @notice Returns the total supply of the token
#define macro TOTAL_SUPPLY() = takes (0) returns (0) {
    NON_PAYABLE()                       // []
    [TOTAL_SUPPLY_SLOT] sload           // [supply]
    0x00 mstore                         // []
    0x20 0x00 return                    // []
}

/// @notice Allowance
/// @notice Returns the amount which a spender is allowed to transfer on behalf of an owner
#define macro ALLOWANCE() = takes (0) returns (0) {
    NON_PAYABLE()                       // []
    0x24 calldataload                   // [to]
    0x04 calldataload                   // [from, to]
    [APPROVAL_SLOT]                     // [slot, from, to]
    LOAD_ELEMENT_FROM_KEYS_2D(0x00)     // [allowance]
    0x00 mstore                         // []
    0x20 0x00 return                    // []
}

/// @notice Reverts with a "MAX_SUPPLY" msg if the condition is false
#define macro MAX_SUPPLY(condition) = takes (0) returns (0) {
    [MAX_SUPPLY_ERROR]              // ["MAX_SUPPLY"]
    [MAX_SUPPLY_LENGTH]             // [10 (length), "MAX_SUPPLY"]
    <condition>                     // [condition, 10 (length), "MAX_SUPPLY"]
    REQUIRE()                       // []
}

/// @notice Mints tokens to a specified address
#define macro _MINT() = takes (2) returns (0) {
    // Input stack: [value, to]
    dup2 _INTERNAL_HARVEST()            // [value, to]
    _INTERNAL_MINT()
}

#define macro _INTERNAL_MINT() = takes (2) returns (0) {
    // Cannot mint more than the maximum supply
    dup1 [TOTAL_SUPPLY_SLOT] sload add  // [newTotalSupply, value, to]
    [MAX_SUPPLY]                        // [maxSupply, newTotalSupply, value, to]
    gt supplyWithinConstraint jumpi     // [value, to]
        MAX_SUPPLY(0x00)                // _reverts_
    supplyWithinConstraint:

    // Transfer the new tokens to the recipient
    dup2                                // [to, value, to]
    swap1                               // [value, to, to]
    _TRANSFER_GIVE_TO()                 // [value, to, to]

    // Update totalSupply
    dup1                                // [value, value, to, to]
    [TOTAL_SUPPLY_SLOT] sload           // [supply, value, value, to, to]
    add                                 // [supply + value, value, to, to]
    [TOTAL_SUPPLY_SLOT] sstore          // [value, to, to]

    // Emit the transfer event.
    0x00 mstore                         // [to, to]
    [ZERO_ADDRESS]                      // [address(0), to, to]
    __EVENT_HASH(Transfer)              // [sig, from, to, to]
    0x20 0x00                           // [0, 32, sig, from, to, to]
    log3 pop                            // []
}


/// @notice Main Execution Entrypoint
/// @notice Dispatches function calls based on the 4byte selector located @ calldata[0x00:0x04]
#define macro MAIN() = {
    // Identify which function is being called.
    pc calldataload 0xE0 shr                                                // [selector]

    // Call the TransientLoan function dispatch
    TRANSIENT_LOAN_MAIN()                                                   // [selector]

    // Dispatch
    dup1 __FUNC_SIG(permit)             eq permitJump           jumpi       // [selector]
    dup1 __FUNC_SIG(nonces)             eq noncesJump           jumpi       // [selector]

    dup1 __FUNC_SIG(name)               eq nameJump             jumpi       // [selector]
    dup1 __FUNC_SIG(symbol)             eq symbolJump           jumpi       // [selector]
    dup1 __FUNC_SIG(decimals)           eq decimalsJump         jumpi       // [selector]
    dup1 __FUNC_SIG(DOMAIN_SEPARATOR)   eq domainSeparatorJump  jumpi       // [selector]

    dup1 __FUNC_SIG(totalSupply)        eq totalSupplyJump      jumpi       // [selector]
    dup1 __FUNC_SIG(balanceOf)          eq balanceOfJump        jumpi       // [selector]
    dup1 __FUNC_SIG(allowance)          eq allowanceJump        jumpi       // [selector]

    dup1 __FUNC_SIG(transfer)           eq transferJump         jumpi       // [selector]
    dup1 __FUNC_SIG(transferFrom)       eq transferFromJump     jumpi       // [selector]
    dup1 __FUNC_SIG(approve)            eq approveJump          jumpi       // [selector]

    dup1 __FUNC_SIG(toggle)             eq toggleJump           jumpi       // [selector]
    dup1 __FUNC_SIG(frozen)             eq frozenJump           jumpi       // [selector]
    dup1 __FUNC_SIG(warden)             eq wardenJump           jumpi       // [selector]

    dup1 __FUNC_SIG(harvestable)        eq harvestableJump      jumpi       // [selector]
    dup1 __FUNC_SIG(harvest)            eq harvestJump          jumpi       // [selector]

    0x00 dup1 revert

    allowanceJump: ALLOWANCE()
    approveJump: APPROVE()
    balanceOfJump: BALANCE_OF()
    decimalsJump: DECIMALS()
    domainSeparatorJump: DOMAIN_SEPARATOR()
    nameJump: NAME()
    noncesJump: NONCES()
    permitJump: PERMIT()
    symbolJump: SYMBOL()
    totalSupplyJump: TOTAL_SUPPLY()
    transferFromJump: TRANSFER_FROM()
    transferJump: TRANSFER()
    toggleJump: TOGGLE()
    frozenJump: GET_FROZEN()
    wardenJump: GET_WARDEN()
    harvestableJump: HARVESTABLE()
    harvestJump: HARVEST()
}